<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Spice.ai blog â€“ deep learning</title><link>/categories/deep-learning/</link><description>Recent content in deep learning on Spice.ai blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 12 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="/categories/deep-learning/index.xml" rel="self" type="application/rss+xml"/><item><title>Posts: Adding Soft Actor-Critic</title><link>/posts/2022/01/12/adding-soft-actor-critic/</link><pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate><guid>/posts/2022/01/12/adding-soft-actor-critic/</guid><description>
&lt;p>Last month in the v0.5-alpha version, a new learning algorithm was added to Spice.ai: Soft Actor-Critic. This is a very popular algorithm in the Reinforcement Learning field. Let&amp;rsquo;s see what it is and why this is an interesting addition.&lt;/p>
&lt;p>The previous article &lt;a href="/posts/2021/12/15/understanding-q-learning-how-a-reward-is-all-you-need/">Understanding Q-learning: How a Reward Is All You Need&lt;/a> is not necessary but can be helpful to understand this article.&lt;/p>
&lt;h2 id="what-is-soft-actor-critic">What is Soft Actor-Critic&lt;/h2>
&lt;h3 id="actor-critic">Actor-Critic&lt;/h3>
&lt;p>Deepmind first introduced the actor-critic approach in deep learning in a &lt;a href="https://arxiv.org/abs/1602.01783">2016 paper&lt;/a>. We can think of this approach as having 2 tasks:&lt;/p>
&lt;ul>
&lt;li>Choosing actions to take: giving probabilities for each possible action (the policy)&lt;/li>
&lt;li>Evaluating values for each action: the estimated reward from those actions (the Q-values)&lt;/li>
&lt;/ul>
&lt;p>Those tasks will be made by 2 different neural networks or a single network that branches out in 2 heads. The actor is the part that outputs the policy, while the critic outputs the values.&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 300px; margin: auto" alt="Actor-Critic Diagram" src="https://user-images.githubusercontent.com/19952490/148524970-e5fab55c-7364-4cb9-870c-7f5b8b58cc6f.png">
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Figure 1. Actor-Critic struture&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>In most cases, this model was proven to perform very well, better than Deep Q-Learning. The actor is trained to prefer actions associated with the best values from the critic. The critic is trained to correctly estimate rewards (current and future ones) of the actions.&lt;/p>
&lt;p>Both will improve over time though we have to keep in mind that the critic is unlikely to evaluate all possible actions in the environment as it will only see actions from states that the actor is likely to take (the policy).&lt;/p>
&lt;p>This bias of the system toward its policy is important: the algorithm is meant to train &lt;em>on-policy&lt;/em>. The duo actor-critic works together: trying to train it with inputs and outputs from another system (humans or even itself in past iterations of its own training) will not work.&lt;/p>
&lt;p>Multiple improvements were made to limit the bias of the actor-critic approach but the necessity to train on-policy remains. This is very limiting as being able to train from any experience can be very valuable for time and data efficiency.&lt;/p>
&lt;h3 id="soft-actor-critic">Soft Actor-Critic&lt;/h3>
&lt;p>Soft Actor-Critic allows an Actor-Critic network to train off-policy. It was introduced in &lt;a href="https://arxiv.org/abs/1801.01290">a paper&lt;/a> in 2018 and included multiple additions to improve its parent algorithm. The main difference is the introduction of the entropy of the actor outputs during the training phase.&lt;/p>
&lt;p>The entropy measures the chaos/order of a system (or uncertainty). If a system always acts the same way, the entropy is minimal. Here the actor&amp;rsquo;s entropy is maximum if all possible actions have the same weight (same probability) and minimum if the actor always chose only a single action with 100% confidence.&lt;/p>
&lt;p>During the training phase, the actor is trained to maintain the entropy of its outputs at a specific value.&lt;/p>
&lt;p>The introduction of the entropy changes the goal of the training not only to find the bests output but to keep exploring the other actions. The critic part will be trained on all actions, even if they may occur only in rare cases.&lt;/p>
&lt;p>There are other essential parts, such as having 2 critics and being able to output continuous values, but the entropy is the crucial difference in this algorithm&amp;rsquo;s training and potential.&lt;/p>
&lt;h2 id="adding-choices-to-spiceai-learning-algorithms">Adding choices to Spice.AI learning algorithms&lt;/h2>
&lt;p>As we saw above, the Actor-Critic algorithm is known to outperform Deep Q-Learning in most cases. If we also want to leverage previous data (off-policy training), Soft Actor-Critic is a natural choice. This approach is heavier despite better theoretical results, making it more suitable for complex tasks. For simpler tasks, Deep Q-Learning will still be an appealing option for its speed of training and its capability to quickly convergence to a good solution.&lt;/p>
&lt;p>We can think of Soft Actor-Critic as a complex machine designed to take actions while keeping a variety of possibilities. Sometimes several options seem equally rewarding: a simpler algorithm would take what it evaluates as the best one even though the margin is small and the precision of its evaluation shouldn&amp;rsquo;t be enough. This tendency to quickly convergence to a solution has its benefits and inconveniences.&lt;/p>
&lt;h2 id="implementation-in-the-source-code">Implementation in the source code&lt;/h2>
&lt;p>Adding new algorithms is essential to Spice.ai, so the procedure was designed to be straightforward.&lt;/p>
&lt;p>Looking a the &lt;a href="https://github.com/spiceai/spiceai">source code&lt;/a>, the code related to training agents is in the &lt;code>ai/src&lt;/code> folder. This part of the code uses the python language as most modern AI libraries are distributed in this language.&lt;/p>
&lt;p>In this folder, every agent is in the &lt;code>algorithms&lt;/code> folder, and each has its subfolder. There is an &lt;code>agent_interface&lt;/code> file that defines the main class that the different agents should inherit from and a &lt;code>factory&lt;/code> script responsible for creating instances of an agent from a given algorithm name.&lt;/p>
&lt;p>Adding a new agent is simple:&lt;/p>
&lt;ul>
&lt;li>making a new folder in the &lt;code>algorithms&lt;/code>&lt;/li>
&lt;li>adding a json file describing the &lt;code>algorithm_id&lt;/code>, &lt;code>name&lt;/code>, and &lt;code>docs_link&lt;/code> (see other json as an example) in the folder&lt;/li>
&lt;li>adding a new python file with a class that would inherit from the &lt;code>SpiceAIAgent&lt;/code> defined in the &lt;code>agent_interface&lt;/code> script&lt;/li>
&lt;li>adding a line in the &lt;code>factory&lt;/code> script to instantiate the new implementation when its name is called.&lt;/li>
&lt;/ul>
&lt;p>For the new agent, inheriting from the main &lt;code>SpiceAIAgent&lt;/code> class, 5 functions need to be implemented:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>add_experience&lt;/strong>: storing inputs and outputs (used during the training)&lt;/li>
&lt;li>&lt;strong>act&lt;/strong>: returning the action to be taken from a given input&lt;/li>
&lt;li>&lt;strong>save&lt;/strong>: saving the agent to a given a path&lt;/li>
&lt;li>&lt;strong>load&lt;/strong>: restoring the agent from a given path&lt;/li>
&lt;li>&lt;strong>learn&lt;/strong>: train iteration (from the accumulated experiences)&lt;/li>
&lt;/ul>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>Soft Actor-Critic is a fascinating algorithm that performs well in complex environments. We now &lt;a href="/posts/2021/12/06/announcing-the-release-of-spice.ai-v0.5-alpha/">support Soft Actor Critic&lt;/a> in Spice.ai, which is another step forward in constantly improving the performance of the AI engine. Additionally, we&amp;rsquo;ll continue improving existing algorithms and adding newer ones over time. We designed the platform for ease of implementation and experimentation so if you&amp;rsquo;d like to try building your own agent, you can get the source code on &lt;a href="https://github.com/spiceai/spiceai">Github&lt;/a> and contribute to the platform. Say hi on &lt;a href="https://discord.gg/kZnTfneP5u">Discord&lt;/a>, reach out on &lt;a href="https://twitter.com/spice_ai">Twitter&lt;/a> or &lt;a href="mailto:hey@spice.ai">email us&lt;/a>.&lt;/p>
&lt;p>I hope you enjoy this post and something new.&lt;/p>
&lt;p>Corentin&lt;/p></description></item><item><title>Posts: Understanding Q-learning: How a Reward Is All You Need</title><link>/posts/2021/12/15/understanding-q-learning-how-a-reward-is-all-you-need/</link><pubDate>Wed, 15 Dec 2021 00:00:00 +0000</pubDate><guid>/posts/2021/12/15/understanding-q-learning-how-a-reward-is-all-you-need/</guid><description>
&lt;p>There are two general ways to train an AI to match a given expectation: we can either give it the expected outputs (commonly named labels) for differents inputs; we call this supervised learning. Or we can provide a reward for each output as a score: this is reinforcement learning (RL).&lt;/p>
&lt;p>Supervised learning works by tweaking all the parameters (weights in neural networks) to fit the desired outputs, expecting that given enough input/label pairs the AI will find common rules that generalize for any input.&lt;/p>
&lt;p>Reinforcement learning&amp;rsquo;s reward is often provided from a simple function that can score any output: we don&amp;rsquo;t know what specific output would be best, but we can recognize how good the result is. In this latter statement there are two underlying concepts we will address in this post:&lt;/p>
&lt;ul>
&lt;li>Can we only tell if the output is good in a binary way, or do we have to quantify the output to train our AI?&lt;/li>
&lt;li>Do we have to give a reward for every AI&amp;rsquo;s output? Can we give a reward only at specific times?&lt;/li>
&lt;/ul>
&lt;p>Those questions are already mostly answered, and many algorithms deal with those topics. Our journey here will be to understand how we tackle those questions and end up with a beautiful formula that is at the core of modern approaches of RL:&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; min-height: 100px; margin: auto" src="/svg/q_learning/q_formula.svg" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Equation 1. Q estimation at the heart of many RL algorithm, also known as the Bellman equation.&lt;/div>
&lt;/div>
&lt;/div>
&lt;h2 id="q-learning">Q-learning&lt;/h2>
&lt;p>The vast majority, if not all, of modern RL algorithms are based on the principles of Q-learning: the idea is to evaluate a &amp;lsquo;reward expectation&amp;rsquo; for each possible action. If we can have a good evaluation, we could maximize the reward by choosing actions with the maximum evaluated rewards. The function giving this expected reward is named Q. For now, we will assume we can have a reward for any action.&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; min-height: 100px; margin: auto" src="/svg/q_learning/q_function.svg" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Equation 2. Definition of the Q function.&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>The &lt;code>t&lt;/code> indices show that the state and action aren&amp;rsquo;t constant and will vary, usually with time/action taken. On the other hand, the &lt;code>Q&lt;/code> function and the reward function &lt;code>r&lt;/code> are unique functions that ideally return the &amp;rsquo;expected reward&amp;rsquo; for any (state, action) pairs.&lt;/p>
&lt;p>For now, we will assume we can have a reward that gives an objective and perfect evaluation of each state/action.&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; margin: auto" src="https://user-images.githubusercontent.com/19952490/145569847-4be91c13-3ffb-4ad8-83c4-fb841e9d2c96.png" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Figure 1. Example of reward given for different actions at a specific state. Here a simple 2D map with a goal.&lt;/div>
&lt;/div>
&lt;/div>
&lt;h3 id="q-table">Q-Table&lt;/h3>
&lt;p>We know that actions&amp;rsquo; outcomes (rewards) will vary depending on the current state we are in, otherwise the problem would be trivial to solve. If the states that are relevant to our actions can be numbered, a simple way would be to build a table with all the possible states/action pairs. There are different ways to build such a table depending on how we can interact with our environment. Eventually, we would have a good &amp;lsquo;map&amp;rsquo; to guide us to do the best actions.&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; margin: auto" src="https://user-images.githubusercontent.com/19952490/145569842-298103e3-e7ed-412f-8229-66c745d29807.png" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Figure 2. Example of Q-table: we can build an exhaustive table for all the possible (state, action) pairs&lt;/div>
&lt;/div>
&lt;/div>
&lt;h3 id="deep-q-learning">Deep Q-Learning&lt;/h3>
&lt;p>When the number of variables of the environment relevant to our actions/rewards becomes too large, the number of possible states grows quickly. It doesn&amp;rsquo;t take a lot of possible parameters to make the Q-table approach unfeasible. Neural networks are known to work very nicely and efficiently in high dimensionality (with many input variables). They also generalize well, so the idea in Deep Q-Learning is to use a neural network to predict the different Q values for each action given a state.&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; margin: auto" src="https://user-images.githubusercontent.com/19952490/145569840-369d4eb0-48c6-44d8-bc5e-bfabdd7713a4.png" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Figure 3. A neural network can predict Q values from state information&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>In this case, we do not need to give the state/action pairs but only the state, as the neural network would exhaustively return all the Q values associated with each action. Outputting all actions&amp;rsquo; Q value is a common method as the general cases have a complex environment but a smaller number of possible actions.&lt;/p>
&lt;p>This method works very well. It is similar to supervised learning with states as inputs and rewards as labels. We assumed so far that we had a reward for each action, and we chose the next action with the best reward (called a greedy policy). In many cases this is not enough: even if an action would yield the best reward at a given state, this may affect the next state so that we wouldn&amp;rsquo;t optimize the reward in the long term. Also, if we can&amp;rsquo;t have a reward for each action, we usually give 0 as a reward. We will not be able to choose the right action if they affect later states despite not yielding different rewards at the current state.&lt;/p>
&lt;p>The sparsity of rewards or the long-term calculation of total reward (non-greedy policies) leads us to diverge from supervised learning and learn potential future rewards.&lt;/p>
&lt;h2 id="temporal-difference-td-learning">Temporal difference: TD-Learning&lt;/h2>
&lt;p>TD-learning is a clever way to account for potential future value without knowing them yet. TD is a model-free class of algorithms: it does not simulate future states. The main idea is to consider all the rewards of a sequence of actions to give a better value than just the reward of the next action.&lt;/p>
&lt;p>We can, for instance, sum all the future rewards:&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; margin: auto" src="https://user-images.githubusercontent.com/19952490/145569849-f528b7df-a240-41d6-b850-fde58334cac5.png" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Figure 4. Cumulating future rewards to assign values to each state.&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>Mathematically this can be written as:&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; min-height: 100px; margin: auto" src="/svg/q_learning/value_naive_function.svg" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Equation 3.&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>This is named TD(0): the simplest form of TD method, accumulating all the rewards.&lt;/p>
&lt;h3 id="introducing-policies">Introducing policies&lt;/h3>
&lt;p>We could try different trajectories (sequence of actions) and retrospectively get the final reward for each action, but this has 2 drawbacks: the environment is usually too vast, and the sequence of actions might not even have a definite end. Also, such exhaustive methods might not be very efficient. Instead, we can evaluate the &amp;lsquo;value&amp;rsquo; of the next state overall, like the maximum of all its possible rewards (direct reward), and add this value to the reward of a given action.&lt;/p>
&lt;p>If a state can have different branches, we can select the best one, and this would be our policy, the way we choose actions. This simple form of taking the maximum is called the &amp;lsquo;greedy&amp;rsquo; policy.&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; margin: auto" src="https://user-images.githubusercontent.com/19952490/145569828-f9505a88-1556-4c88-ba43-834daa60e594.png" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Figure 5. With a greedy policy the associated values to state come from the maximum value of the next state. Here despite the lower branch giving only half the top reward directly the overall value is greater.&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>This can be written down as:&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; min-height: 100px; margin: auto" src="/svg/q_learning/value_policy_function.svg" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Equation 4.&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>The expected value notation is defined as:&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; min-height: 100px; margin: auto" src="/svg/q_learning/expected_value.svg" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Equation 5.&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>For a greedy policy the probabilities &lt;code>p&lt;/code> would all be set to 0 but the one associated with the highest return to 1 (in case of equality between n actions, we would attribute &amp;lsquo;1/n&amp;rsquo; as probabilities to get the same expected value).&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; min-height: 100px; margin: auto" src="/svg/q_learning/expected_greedy_value.svg" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Equation 6.&lt;/div>
&lt;/div>
&lt;/div>
&lt;h3 id="relation-with-q-function">Relation with Q function&lt;/h3>
&lt;p>The expected reward can be replaced by the Q function we used earlier, which now can be denominated to be specific to our chosen policy (named Ï€):&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; min-height: 100px; margin: auto" src="/svg/q_learning/value_q_relation.svg" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Equation 7.&lt;/div>
&lt;/div>
&lt;/div>
&lt;h3 id="td-0">TD-0&lt;/h3>
&lt;p>We previously discussed the problem of not being able to go through all the states exhaustively and that the evaluation of the Q value from a neural network could help. We want to use the TD method to have a better value estimation that will consider potential future rewards.&lt;/p>
&lt;p>The TD(0) method is elegant as we can, in fact, only use the next state&amp;rsquo;s expected value instead of all future ones. The idea is that with successive evaluations, we build a chain of dependencies as each states&amp;rsquo; value depends on the next one.&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; min-height: 100px; margin: auto" src="/svg/q_learning/td_0_value.svg" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Equation 8.&lt;/div>
&lt;/div>
&lt;/div>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; margin: auto" src="https://user-images.githubusercontent.com/19952490/145569853-335f65d9-aa16-44c6-9e97-287db5862628.png" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Figure 6. Iterative propagation of state values following TD(0) method.&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>We can see that the greedy policy would work even with null rewards in the trajectory. We can explicit our greedy policy, going back to use Q value instead of the state value V:&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; min-height: 100px; margin: auto" src="/svg/q_learning/td_0_q.svg" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Equation 9.&lt;/div>
&lt;/div>
&lt;/div>
&lt;h3 id="td-lambda">TD-lambda&lt;/h3>
&lt;p>We need to fix a problem: if a trajectory grows too long or never ends, a state value can potentially grow indefinitely. To counter that, we can add a &lt;strong>discount factor&lt;/strong> (originally named lambda, usually refer as gamma in Q-learning) for the next state&amp;rsquo;s value:&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; min-height: 100px; margin: auto" src="/svg/q_learning/td_lambda_q.svg" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Equation 10.&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>Notice that we simplify the reward notation for clarity.&lt;/p>
&lt;p>To avoid exploding values, this discount has to be between 0 and 1 (strictly below 1). We can think about it as giving more importance to the direct reward than the future ones. As the contribution to the latter reward decrease, the chain of action can grow without the calculated value growing. If the reward has an upper limit, the value will also be bounded.&lt;/p>
&lt;p>The sparsity of rewards is also solved: giving only a positive reward after many non-rewarding steps will create smooth values for the intermediate states. Any reward, positive or negative, will diffuse its value to the neighbor states.&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 600px; margin: auto" src="https://user-images.githubusercontent.com/19952490/145569835-ff21b42f-21d0-4eb3-a451-9b9aa5a76f78.png" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Figure 7. The TD(0) value propagation can allow for a smooth value distribution over the state that will help building efficient behaviour.&lt;/div>
&lt;/div>
&lt;/div>
&lt;h2 id="q-learning-algorithm">Q-Learning algorithm&lt;/h2>
&lt;p>Finally, as we train a neural network to estimate the Q function, we need to update its target with successive iteration. We cannot fully trust the estimator (a neural network here) to give the correct value, so we introduce a learning rate to update the target smoothly.&lt;/p>
&lt;div style="display: flex; justify-content: center; padding: 5px;">
&lt;div style="display: flex; flex-direction: column;">
&lt;img style="max-width: 800px; min-height: 160px; margin: auto" src="/svg/q_learning/final_formula.svg" />
&lt;div style="font-size: 0.8rem; font-style: italic; text-align: center;">Equation 11. Fully explained Bellman equation.&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>That is it! We now understand all the parts of this formula. Over multiple training steps with different sates, the training should find a good average Q function. While training, the estimator uses its own output to train itself (commonly referred to as bootstrapping): it is like it is chasing itself. Bootstrapping can lead to instability in the training process. There are many additional methods to help against such instability.&lt;/p>
&lt;p>From giving rewards, sparse or not, binary or fine-grained, we have a smooth space of values for all our states/actions so the AI can follow a greedy policy to the best outcome.&lt;/p>
&lt;p>This way of training is not a silver bullet and there is no guarantee that the AI will find a correlation from the information given as state to the returned reward.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>We can see how our rewards are used to train AI&amp;rsquo;s policies using Q-learning. By understanding the many iterations required and the bootstrapping issues, we can help our AI by carefully giving relevant state information and reward:&lt;/p>
&lt;ul>
&lt;li>There needs to be a correlation between the state information and the reward: the simpler the relationship, the easier/faster the AI will find it.&lt;/li>
&lt;li>Sparse and binary rewards make the training problem long and arduous. Giving more information through the reward can tremendously increase the speed/accuracy of the learned Q-estimator.&lt;/li>
&lt;li>The longer the chain of actions, the more complex the Q-value will be to estimate.&lt;/li>
&lt;/ul>
&lt;p>We didn&amp;rsquo;t see how the AI&amp;rsquo;s algorithm can explore different actions given an environment here. Spice.ai&amp;rsquo;s technology focuses exclusively on off-policy training where we only have past data and cannot interact with the environment. RL is a vast topic and currently quickly growing. Robotics is a fantastic field of application; many other areas are yet to be explored with such a technology. We hope to push forward the technology and its field of application with our platform.&lt;/p>
&lt;p>If you&amp;rsquo;d like to partner with us on the mission of making new applications by leveraging RL, we invite you to discuss with us on &lt;a href="https://discord.gg/kZnTfneP5u">Discord&lt;/a>, reach out on &lt;a href="https://twitter.com/spice_ai">Twitter&lt;/a> or &lt;a href="mailto:hey@spice.ai">email us&lt;/a>.&lt;/p>
&lt;p>I hope you enjoy this post and learn new things.&lt;/p>
&lt;p>Corentin&lt;/p></description></item></channel></rss>